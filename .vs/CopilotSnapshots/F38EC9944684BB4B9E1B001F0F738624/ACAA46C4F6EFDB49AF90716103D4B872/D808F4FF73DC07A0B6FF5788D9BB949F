using FNZ_ChatBot.Models;
using FNZ_ChatBot.Data;
using Microsoft.EntityFrameworkCore;
using System.Text.RegularExpressions;
using Microsoft.ML;
using Microsoft.ML.Data;

namespace FNZ_ChatBot.Services
{
    public class ChatService : IChatService
    {
        private readonly ApplicationDbContext _context;
        private readonly MLContext _mlContext;
        private ITransformer _model;
        private List<KnowledgeBaseItem> _knowledgeCache;
        private Dictionary<int, float[]> _embeddings;

        public ChatService(ApplicationDbContext context)
        {
            _context = context;
            _mlContext = new MLContext(seed: 0);
            InitializeSemanticSearch();
        }

        private void InitializeSemanticSearch()
        {
            try
            {
                // Charger les données de la base de connaissances
                _knowledgeCache = _context.KnowledgeBase
                    .Where(k => k.IsActive)
                    .ToList();

                if (_knowledgeCache.Any())
                {
                    // Créer les données d'entraînement
                    var trainingData = _knowledgeCache.Select(k => new TextData { Text = k.Question }).ToList();
                    
                    // Créer le pipeline de transformation
                    var dataView = _mlContext.Data.LoadFromEnumerable(trainingData);
                    var pipeline = _mlContext.Transforms.Text.FeaturizeText("Features", nameof(TextData.Text));
                    
                    // Entraîner le modèle
                    _model = pipeline.Fit(dataView);
                    
                    // Pré-calculer les embeddings pour toutes les questions
                    _embeddings = new Dictionary<int, float[]>();
                    foreach (var item in _knowledgeCache)
                    {
                        _embeddings[item.Id] = GetEmbedding(item.Question);
                    }
                }
            }
            catch (Exception ex)
            {
                // Log l'erreur mais continuez avec la recherche textuelle de base
                Console.WriteLine($"Erreur lors de l'initialisation de la recherche sémantique : {ex.Message}");
            }
        }

        private float[] GetEmbedding(string text)
        {
            if (_model == null || string.IsNullOrWhiteSpace(text))
                return Array.Empty<float>();

            try
            {
                var data = new[] { new TextData { Text = text } };
                var dataView = _mlContext.Data.LoadFromEnumerable(data);
                var transformedData = _model.Transform(dataView);
                
                var features = _mlContext.Data.CreateEnumerable<TextFeatures>(transformedData, reuseRowObject: false).FirstOrDefault();
                return features?.Features ?? Array.Empty<float>();
            }
            catch
            {
                return Array.Empty<float>();
            }
        }

        private float CosineSimilarity(float[] vector1, float[] vector2)
        {
            if (vector1 == null || vector2 == null || vector1.Length != vector2.Length || vector1.Length == 0)
                return 0f;

            float dotProduct = 0f, magnitude1 = 0f, magnitude2 = 0f;
            
            for (int i = 0; i < vector1.Length; i++)
            {
                dotProduct += vector1[i] * vector2[i];
                magnitude1 += vector1[i] * vector1[i];
                magnitude2 += vector2[i] * vector2[i];
            }

            if (magnitude1 == 0f || magnitude2 == 0f)
                return 0f;

            return dotProduct / (float)(Math.Sqrt(magnitude1) * Math.Sqrt(magnitude2));
        }

        public string GetResponse(string userInput)
        {
            return GetResponseAsync(userInput).Result;
        }

        public async Task<string> GetResponseAsync(string userInput, string? userId = null, int? conversationId = null)
        {
            var response = await GetResponseInternal(userInput);
            
            // Enregistrer dans l'historique si un utilisateur est connecté
            if (!string.IsNullOrEmpty(userId))
            {
                var conversationHistory = new ConversationHistory
                {
                    UserId = userId,
                    ConversationId = conversationId,
                    Question = userInput,
                    Response = response,
                    CreatedDate = DateTime.UtcNow
                };

                _context.ConversationHistory.Add(conversationHistory);
                await _context.SaveChangesAsync();
            }

            return response;
        }

        private async Task<string> GetResponseInternal(string userInput)
        {
            if (string.IsNullOrWhiteSpace(userInput))
                return "Veuillez entrer une question.";

            // Gestion des salutations standard
            if (IsGreeting(userInput))
                return GetGreetingResponse();

            // Gestion des questions de politesse
            if (IsPoliteQuestion(userInput))
                return GetPoliteResponse(userInput);

            // Recharger les données si le cache est vide
            if (_knowledgeCache == null || !_knowledgeCache.Any())
            {
                await RefreshKnowledgeCache();
            }

            // Si toujours pas de données, utiliser les réponses standard
            if (_knowledgeCache == null || !_knowledgeCache.Any())
            {
                return GetStandardResponse(userInput);
            }

            // Recherche sémantique dans la base de connaissances
            var semanticResults = await SearchSemanticMatches(userInput);
            
            if (semanticResults.Any())
            {
                return FormatSemanticResponse(semanticResults);
            }

            // Si aucun résultat sémantique, essayer la recherche textuelle
            var textualResults = await SearchTextualMatches(userInput);
            
            if (textualResults.Any())
            {
                return FormatTextualResponse(textualResults);
            }

            // Si rien trouvé, retourner une réponse générique
            return GetFallbackResponse();
        }

        private bool IsGreeting(string input)
        {
            var greetings = new[] { "bonjour", "salut", "hello", "hey", "coucou", "bonsoir" };
            return greetings.Any(g => input.ToLower().Contains(g));
        }

        private string GetGreetingResponse()
        {
            var responses = new[]
            {
                "Bonjour ! Comment puis-je vous aider aujourd'hui ?",
                "Salut ! Je suis là pour répondre à vos questions.",
                "Bonjour ! Que puis-je faire pour vous ?",
                "Salut ! N'hésitez pas à me poser vos questions."
            };
            return responses[new Random().Next(responses.Length)];
        }

        private bool IsPoliteQuestion(string input)
        {
            var politeQuestions = new[] { "comment allez-vous", "comment ça va", "ça va", "comment vous portez-vous" };
            return politeQuestions.Any(q => input.ToLower().Contains(q));
        }

        private string GetPoliteResponse(string input)
        {
            return "Je vais bien, merci ! Je suis prêt à vous aider. Quelle est votre question ?";
        }

        private string GetStandardResponse(string input)
        {
            // Réponses pour questions communes
            var lowerInput = input.ToLower();
            
            if (lowerInput.Contains("qui êtes-vous") || lowerInput.Contains("qui es-tu"))
                return "Je suis l'assistant virtuel FNZ, conçu pour vous aider avec vos questions.";
                
            if (lowerInput.Contains("que pouvez-vous faire") || lowerInput.Contains("vos fonctionnalités"))
                return "Je peux répondre à vos questions en me basant sur la base de connaissances FNZ. N'hésitez pas à me poser vos questions !";
                
            if (lowerInput.Contains("merci"))
                return "De rien ! N'hésitez pas si vous avez d'autres questions.";
                
            return "Je suis désolé, je n'ai pas trouvé d'information pertinente dans ma base de connaissances. Pouvez-vous reformuler votre question ou être plus spécifique ?";
        }

        private async Task RefreshKnowledgeCache()
        {
            _knowledgeCache = await _context.KnowledgeBase
                .Where(k => k.IsActive)
                .ToListAsync();
                
            if (_knowledgeCache.Any())
            {
                InitializeSemanticSearch();
            }
        }

        private async Task<List<(KnowledgeBase item, float score)>> SearchSemanticMatches(string userInput)
        {
            if (_model == null || _embeddings == null || !_embeddings.Any())
                return new List<(KnowledgeBase, float)>();

            try
            {
                var inputEmbedding = GetEmbedding(userInput);
                if (inputEmbedding.Length == 0)
                    return new List<(KnowledgeBase, float)>();

                var results = new List<(KnowledgeBase item, float score)>();
                var threshold = 0.3f; // Seuil de similarité

                foreach (var item in _knowledgeCache)
                {
                    if (_embeddings.TryGetValue(item.Id, out var itemEmbedding))
                    {
                        var similarity = CosineSimilarity(inputEmbedding, itemEmbedding);
                        if (similarity > threshold) // Seuil de similarité
                        {
                            results.Add((item, similarity));
                        }
                    }
                }

                return results
                    .OrderByDescending(r => r.score)
                    .Take(3)
                    .ToList();
            }
            catch
            {
                return new List<(KnowledgeBase, float)>();
            }
        }

        private async Task<List<KnowledgeBase>> SearchTextualMatches(string userInput)
        {
            var subQuestions = SplitQuestions(userInput);
            var allMatches = new List<KnowledgeBase>();

            foreach (var question in subQuestions)
            {
                var matches = _knowledgeCache
                    .Where(k => k.Question.ToLower().Contains(question.ToLower()) || 
                               question.ToLower().Contains(k.Question.ToLower()) ||
                               CalculateTextSimilarity(k.Question.ToLower(), question.ToLower()) > 0.3)
                    .OrderByDescending(k => CalculateTextSimilarity(k.Question.ToLower(), question.ToLower()))
                    .Take(2)
                    .ToList();

                allMatches.AddRange(matches);
            }

            return allMatches.Distinct().ToList();
        }

        private string FormatSemanticResponse(List<(KnowledgeBase item, float score)> results)
        {
            if (results.Count == 1)
            {
                return results[0].item.Response;
            }

            var response = "Voici les informations pertinentes que j'ai trouvées :\n\n";
            
            for (int i = 0; i < results.Count; i++)
            {
                var result = results[i];
                response += $"**{i + 1}.** {result.item.Response}\n\n";
            }

            return response.Trim();
        }

        private string FormatTextualResponse(List<KnowledgeBase> results)
        {
            if (results.Count == 1)
            {
                return results[0].Response;
            }

            var response = "Voici les informations que j'ai trouvées :\n\n";
            
            for (int i = 0; i < results.Count; i++)
            {
                response += $"**{i + 1}.** {results[i].Response}\n\n";
            }

            return response.Trim();
        }

        private string GetFallbackResponse()
        {
            var responses = new[]
            {
                "Je suis désolé, je n'ai pas trouvé d'information pertinente dans ma base de connaissances. Pouvez-vous reformuler votre question ?",
                "Je ne trouve pas de réponse appropriée à votre question. Pourriez-vous être plus spécifique ?",
                "Cette question dépasse mes connaissances actuelles. Un administrateur peut ajouter cette information dans la base de connaissances."
            };
            return responses[new Random().Next(responses.Length)];
        }

        // Découpe une entrée utilisateur en sous-questions
        private List<string> SplitQuestions(string input)
        {
            var rawParts = Regex.Split(input, @"\?| et | puis |&|\n|-", RegexOptions.IgnoreCase)
                                .Select(q => q.Trim())
                                .Where(q => !string.IsNullOrWhiteSpace(q))
                                .ToList();

            var filteredParts = rawParts.Where(q => q.Split(' ').Length >= 3).ToList();
            return filteredParts.Any() ? filteredParts : new List<string> { input };
        }

        // Calcul simple de similarité entre deux chaînes
        private double CalculateTextSimilarity(string text1, string text2)
        {
            if (string.IsNullOrEmpty(text1) || string.IsNullOrEmpty(text2))
                return 0;

            var words1 = text1.Split(' ', StringSplitOptions.RemoveEmptyEntries);
            var words2 = text2.Split(' ', StringSplitOptions.RemoveEmptyEntries);

            var commonWords = words1.Intersect(words2).Count();
            var totalWords = words1.Union(words2).Count();

            return totalWords == 0 ? 0 : (double)commonWords / totalWords;
        }
    }

    // Classes pour ML.NET
    public class TextData
    {
        public string Text { get; set; } = string.Empty;
    }

    public class TextFeatures
    {
        [VectorType(65536)] // Taille du vecteur de features pour le texte
        public float[] Features { get; set; } = Array.Empty<float>();
    }
}
