using FNZ_ChatBot.Models;
using FNZ_ChatBot.Services;
using FNZ_ChatBot.Data;
using Microsoft.EntityFrameworkCore;
using Microsoft.ML;
using Microsoft.ML.Data;

namespace FNZ_ChatBot.Services
{
    public class SemanticChatService : IChatService
    {
        private readonly ApplicationDbContext _context;
        private readonly MLContext _mlContext;
        private ITransformer _model;
        private List<KnowledgeBase> _knowledgeCache;
        private Dictionary<int, float[]> _embeddings;
        private readonly Dictionary<string, string> _standardResponses = new();

        public SemanticChatService(ApplicationDbContext context)
        {
            _context = context;
            _mlContext = new MLContext(seed: 0);
            InitializeStandardResponses();
            InitializeSemanticSearch();
        }

        private void InitializeStandardResponses()
        {
            // Salutations
            _standardResponses["bonjour"] = "Bonjour ! Comment puis-je vous aider aujourd'hui ?";
            _standardResponses["salut"] = "Salut ! Je suis là pour répondre à vos questions.";
            _standardResponses["hello"] = "Hello ! Que puis-je faire pour vous ?";
            _standardResponses["bonsoir"] = "Bonsoir ! Comment puis-je vous aider ?";
            
            // Questions sur l'assistant
            _standardResponses["qui êtes-vous"] = "Je suis l'assistant virtuel FNZ, conçu pour vous aider avec vos questions professionnelles.";
            _standardResponses["qui es-tu"] = "Je suis l'assistant virtuel FNZ, conçu pour vous aider avec vos questions professionnelles.";
            _standardResponses["que pouvez-vous faire"] = "Je peux répondre à vos questions en me basant sur la base de connaissances FNZ. N'hésitez pas à me poser vos questions !";
            _standardResponses["vos fonctionnalités"] = "Je peux vous aider avec toutes les informations présentes dans la base de connaissances FNZ. Posez-moi vos questions !";
            
            // Politesse
            _standardResponses["comment allez-vous"] = "Je vais bien, merci ! Je suis prêt à vous aider. Quelle est votre question ?";
            _standardResponses["comment ça va"] = "Ça va très bien ! Comment puis-je vous aider ?";
            _standardResponses["merci"] = "De rien ! N'hésitez pas si vous avez d'autres questions.";
            _standardResponses["au revoir"] = "Au revoir ! N'hésitez pas à revenir si vous avez d'autres questions.";
            
            // Questions d'aide
            _standardResponses["aide"] = "Je suis là pour vous aider ! Posez-moi vos questions sur les sujets couverts par la base de connaissances FNZ.";
            _standardResponses["comment utiliser"] = "Posez-moi simplement vos questions en français. Je vais chercher les meilleures réponses dans la base de connaissances.";
        }

        private void InitializeSemanticSearch()
        {
            try
            {
                RefreshKnowledgeCache().Wait();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Erreur lors de l'initialisation : {ex.Message}");
            }
        }

        private async Task RefreshKnowledgeCache()
        {
            _knowledgeCache = await _context.KnowledgeBase
                .Where(k => k.IsActive)
                .ToListAsync();

            if (_knowledgeCache.Any())
            {
                try
                {
                    // Créer les données d'entraînement
                    var trainingData = _knowledgeCache.Select(k => new SemanticTextData { Text = k.Question }).ToList();
                    
                    // Créer le pipeline de transformation
                    var dataView = _mlContext.Data.LoadFromEnumerable(trainingData);
                    var pipeline = _mlContext.Transforms.Text.FeaturizeText("Features", nameof(SemanticTextData.Text));
                    
                    // Entraîner le modèle
                    _model = pipeline.Fit(dataView);
                    
                    // Pré-calculer les embeddings pour toutes les questions
                    _embeddings = new Dictionary<int, float[]>();
                    foreach (var item in _knowledgeCache)
                    {
                        var embedding = GetEmbedding(item.Question);
                        if (embedding.Length > 0)
                        {
                            _embeddings[item.Id] = embedding;
                        }
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Erreur lors de la création du modèle sémantique : {ex.Message}");
                }
            }
        }

        private float[] GetEmbedding(string text)
        {
            if (_model == null || string.IsNullOrWhiteSpace(text))
                return Array.Empty<float>();

            try
            {
                var data = new[] { new SemanticTextData { Text = text } };
                var dataView = _mlContext.Data.LoadFromEnumerable(data);
                var transformedData = _model.Transform(dataView);
                
                var features = _mlContext.Data.CreateEnumerable<SemanticTextFeatures>(transformedData, reuseRowObject: false).FirstOrDefault();
                return features?.Features ?? Array.Empty<float>();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Erreur lors de la création de l'embedding : {ex.Message}");
                return Array.Empty<float>();
            }
        }

        public string GetResponse(string userInput)
        {
            return GetResponseAsync(userInput).Result;
        }

        public async Task<string> GetResponseAsync(string userInput, string? userId = null, int? conversationId = null)
        {
            var response = await GetResponseInternal(userInput);
            
            // Enregistrer dans l'historique si un utilisateur est connecté
            if (!string.IsNullOrEmpty(userId))
            {
                var conversationHistory = new ConversationHistory
                {
                    UserId = userId,
                    ConversationId = conversationId,
                    Question = userInput,
                    Response = response,
                    CreatedDate = DateTime.UtcNow
                };

                _context.ConversationHistory.Add(conversationHistory);
                await _context.SaveChangesAsync();
            }

            return response;
        }

        private async Task<string> GetResponseInternal(string userInput)
        {
            if (string.IsNullOrWhiteSpace(userInput))
                return "Veuillez entrer une question.";

            var normalizedInput = userInput.ToLower().Trim();

            // 1. Vérifier les réponses standard d'abord
            var standardResponse = GetStandardResponse(normalizedInput);
            if (!string.IsNullOrEmpty(standardResponse))
                return standardResponse;

            // 2. Si pas de cache de connaissances, le recharger
            if (_knowledgeCache == null || !_knowledgeCache.Any())
            {
                await RefreshKnowledgeCache();
            }

            // 3. Si toujours pas de données, retourner message d'erreur
            if (_knowledgeCache == null || !_knowledgeCache.Any())
            {
                return "La base de connaissances est actuellement vide. Veuillez contacter un administrateur pour ajouter du contenu.";
            }

            // 4. Recherche textuelle améliorée AVANT la recherche sémantique (plus rapide et souvent plus précise)
            var textualResults = SearchTextualMatches(userInput);
            if (textualResults.Any())
            {
                return FormatTextualResponse(textualResults);
            }

            // 5. Recherche sémantique avec seuil plus bas si pas de résultats textuels
            if (_model != null && _embeddings != null && _embeddings.Any())
            {
                var semanticResults = SearchSemanticMatches(userInput);
                if (semanticResults.Any())
                {
                    return FormatResponse(semanticResults, "Voici les informations les plus pertinentes :");
                }
            }

            // 6. Recherche de dernier recours avec des critères très souples
            var lastResortResults = SearchLastResort(userInput);
            if (lastResortResults.Any())
            {
                return FormatTextualResponse(lastResortResults) + 
                       "\n\n*Note: Cette réponse pourrait ne pas être exactement ce que vous cherchez. N'hésitez pas à reformuler votre question.*";
            }

            // 7. Aucun résultat trouvé
            return GetNoResultsResponse();
        }

        private string GetStandardResponse(string normalizedInput)
        {
            foreach (var (key, response) in _standardResponses)
            {
                if (normalizedInput.Contains(key))
                {
                    return response;
                }
            }
            return string.Empty;
        }

        private List<(KnowledgeBase item, float score)> SearchSemanticMatches(string userInput)
        {
            try
            {
                var inputEmbedding = GetEmbedding(userInput);
                if (inputEmbedding.Length == 0)
                    return new List<(KnowledgeBase, float)>();

                var results = new List<(KnowledgeBase item, float score)>();

                foreach (var item in _knowledgeCache)
                {
                    if (_embeddings.TryGetValue(item.Id, out var itemEmbedding))
                    {
                        var similarity = CosineSimilarity(inputEmbedding, itemEmbedding);
                        if (similarity > 0.1f) // Seuil très bas pour capturer plus de résultats
                        {
                            results.Add((item, similarity));
                        }
                    }
                }

                return results
                    .OrderByDescending(r => r.score)
                    .Take(3)
                    .ToList();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Erreur lors de la recherche sémantique : {ex.Message}");
                return new List<(KnowledgeBase, float)>();
            }
        }

        private List<KnowledgeBase> SearchTextualMatches(string userInput)
        {
            try
            {
                var normalizedInput = userInput.ToLower();
                var keywords = ExtractKeywords(normalizedInput);
                var allWords = normalizedInput.Split(new[] { ' ', ',', '.', '!', '?' }, StringSplitOptions.RemoveEmptyEntries)
                                            .Where(w => w.Length > 2)
                                            .ToList();
                
                var results = _knowledgeCache
                    .Select(k => new
                    {
                        Item = k,
                        Score = CalculateMatchScore(k, normalizedInput, keywords, allWords)
                    })
                    .Where(x => x.Score > 0)
                    .OrderByDescending(x => x.Score)
                    .Take(3)
                    .Select(x => x.Item)
                    .ToList();

                return results;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Erreur lors de la recherche textuelle : {ex.Message}");
                return new List<KnowledgeBase>();
            }
        }

        private List<KnowledgeBase> SearchLastResort(string userInput)
        {
            try
            {
                var normalizedInput = userInput.ToLower();
                var words = normalizedInput.Split(new[] { ' ', ',', '.', '!', '?' }, StringSplitOptions.RemoveEmptyEntries)
                                          .Where(w => w.Length > 3) // Mots plus longs seulement
                                          .ToList();

                if (!words.Any()) return new List<KnowledgeBase>();

                return _knowledgeCache
                    .Where(k => words.Any(word => 
                        k.Question.ToLower().Contains(word) || 
                        k.Response.ToLower().Contains(word)))
                    .Take(2)
                    .ToList();
            }
            catch
            {
                return new List<KnowledgeBase>();
            }
        }

        private List<string> ExtractKeywords(string input)
        {
            // Dictionnaire de mots-clés techniques étendus
            var technicalKeywords = new HashSet<string>
            {
                // Base de données
                "sql", "base", "données", "connexion", "connect", "database", "serveur", "server",
                "requête", "query", "select", "insert", "update", "delete", "join",
                
                // Git et versioning
                "git", "github", "repository", "clone", "merge", "branch", "commit", "push", "pull",
                "conflit", "conflict", "version", "versioning",
                
                // API et web
                "api", "rest", "controller", "endpoint", "http", "https", "web", "service",
                "json", "xml", "request", "response", "get", "post", "put", "delete",
                
                // Framework .NET
                "entity", "framework", "migration", "ef", "orm", "linq",
                "asp.net", "core", "mvc", "razor", "blazor",
                
                // Programmation C#
                "c#", "csharp", "dotnet", ".net", "visual", "studio", "code",
                "class", "method", "property", "interface", "namespace",
                "async", "await", "task", "thread", "parallel",
                
                // Cloud et déploiement
                "azure", "cloud", "deployment", "publish", "docker", "container",
                
                // Debugging et erreurs
                "debug", "exception", "error", "bug", "erreur", "problème",
                
                // Sécurité
                "jwt", "token", "auth", "authorize", "login", "password", "sécurité",
                
                // Autres
                "application", "app", "projet", "project", "solution", "fichier", "file"
            };

            var words = input.Split(new[] { ' ', ',', '.', '!', '?' }, StringSplitOptions.RemoveEmptyEntries)
                            .Select(w => w.ToLower().Trim())
                            .Where(w => w.Length > 2)
                            .ToList();

            return words.Where(w => technicalKeywords.Contains(w)).ToList();
        }

        private double CalculateMatchScore(KnowledgeBase item, string input, List<string> keywords, List<string> allWords)
        {
            double score = 0;
            var questionLower = item.Question.ToLower();
            var responseLower = item.Response.ToLower();
            
            // Score pour correspondance exacte de phrases
            if (questionLower.Contains(input)) score += 50;
            if (responseLower.Contains(input)) score += 30;
            
            // Score pour correspondance partielle
            if (input.Contains(questionLower)) score += 40;
            
            // Score pour similarité textuelle
            score += CalculateTextSimilarity(questionLower, input) * 20;
            
            // Score pour mots-clés techniques trouvés
            foreach (var keyword in keywords)
            {
                if (questionLower.Contains(keyword)) score += 10;
                if (responseLower.Contains(keyword)) score += 5;
            }
            
            // Score pour mots communs
            foreach (var word in allWords)
            {
                if (questionLower.Contains(word)) score += 3;
                if (responseLower.Contains(word)) score += 2;
            }
            
            return score;
        }

        private string FormatResponse(List<(KnowledgeBase item, float score)> results, string introduction)
        {
            if (!results.Any())
                return GetNoResultsResponse();

            if (results.Count == 1)
            {
                return results[0].item.Response;
            }

            var response = introduction + "\n\n";
            
            for (int i = 0; i < results.Count; i++)
            {
                var result = results[i];
                response += $"**{i + 1}.** {result.item.Response}\n\n";
            }

            return response.Trim();
        }

        private string FormatTextualResponse(List<KnowledgeBase> results)
        {
            if (!results.Any())
                return GetNoResultsResponse();

            if (results.Count == 1)
            {
                return results[0].Response;
            }

            var response = "Voici les informations que j'ai trouvées :\n\n";
            
            for (int i = 0; i < results.Count; i++)
            {
                response += $"**{i + 1}.** {results[i].Response}\n\n";
            }

            return response.Trim();
        }

        private string GetNoResultsResponse()
        {
            var responses = new[]
            {
                "Je suis désolé, je n'ai pas trouvé d'information pertinente dans ma base de connaissances pour cette question. Essayez de reformuler avec des mots-clés différents.",
                "Cette question dépasse mes connaissances actuelles. Pourriez-vous être plus spécifique ou utiliser d'autres termes ?",
                "Je ne trouve pas de réponse appropriée à votre question. Essayez avec des mots-clés comme 'SQL', 'Git', 'API', ou 'C#' si votre question concerne ces sujets.",
            };
            return responses[new Random().Next(responses.Length)];
        }

        private float CosineSimilarity(float[] vector1, float[] vector2)
        {
            if (vector1 == null || vector2 == null || vector1.Length != vector2.Length || vector1.Length == 0)
                return 0f;

            float dotProduct = 0f, magnitude1 = 0f, magnitude2 = 0f;
            
            for (int i = 0; i < vector1.Length; i++)
            {
                dotProduct += vector1[i] * vector2[i];
                magnitude1 += vector1[i] * vector1[i];
                magnitude2 += vector2[i] * vector2[i];
            }

            if (magnitude1 == 0f || magnitude2 == 0f)
                return 0f;

            return dotProduct / (float)(Math.Sqrt(magnitude1) * Math.Sqrt(magnitude2));
        }

        private double CalculateTextSimilarity(string text1, string text2)
        {
            if (string.IsNullOrEmpty(text1) || string.IsNullOrEmpty(text2))
                return 0;

            var words1 = text1.Split(' ', StringSplitOptions.RemoveEmptyEntries);
            var words2 = text2.Split(' ', StringSplitOptions.RemoveEmptyEntries);

            var commonWords = words1.Intersect(words2).Count();
            var totalWords = words1.Union(words2).Count();

            return totalWords == 0 ? 0 : (double)commonWords / totalWords;
        }
    }

    // Classes pour ML.NET avec noms uniques
    public class SemanticTextData
    {
        public string Text { get; set; } = string.Empty;
    }

    public class SemanticTextFeatures
    {
        [VectorType(65536)]
        public float[] Features { get; set; } = Array.Empty<float>();
    }
}
